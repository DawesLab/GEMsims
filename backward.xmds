<?xmlversion = "2.0" encoding = "UTF-8"?><simulation xmds-version="2">  <name>thlcp</name>  <author> M.Hosseini </author>  <description>    Three level atom example simulation. Illustrates a counter-propagating fields.  </description>  <features>    <benchmark/>    <error_check/>    <bing/>    <fftw plan="patient"/>    <globals>      <![CDATA[      const real g = 1;      const real samplelength = 1; //cm      const real time_input = 2;      const real sigma = 0.5;      const real inp_hgt = 1;      const real gama = 1;      const real eta = 500;      const real om = 30;      const real gama0 = 0;      const real gamac = 0.0;      const real w12 = 1.0;      const real timeswitchz = 5.0;      const real timeswitchc = 5.0;      const real N = 20000;      const real delta = 600; ]]>    </globals>  </features><!--In the following part, all of the dimensions used in the problem are defined, but in this case, only the dimensions of "time" and "z" are needed -->  <geometry>    <propagation_dimension> t </propagation_dimension>    <transverse_dimensions>      <dimension name="z" lattice="16000" domain="(0,1)" />    </transverse_dimensions>  </geometry><!--In the following part "b" stands for the backward propagating field --><vector name="main" initial_space="z" type="complex"><components> alpha12 alpha13 alphab13 alphab12 </components><initialisation><![CDATA[alpha12 = 0;alpha13 = 0;alphab13 = 0;alphab12 = 0;]]></initialisation></vector><vector name="cross1" initial_space="z" type="complex">  <components>    E  </components></vector><vector name="cross2" initial_space="z" type="complex">  <components>    Eb  </components></vector><!-- Here we define what differential equations need to be solved and what algorithm we want to use --><sequence><integrate algorithm="ARK89" interval="10" steps="8000" tolerance="1.0e-6"><samples> 400 400 </samples><operators><operator kind="cross_propagation" algorithm="RK4" propagation_dimension="z"><integration_vectors> cross1 </integration_vectors><!--You can have a dependencies tag here. --><dependencies> main </dependencies><boundary_condition kind="left"><![CDATA[E = inp_hgt * exp(-(t - time_input) * (t - time_input)/(2 * sigma * sigma));]]></boundary_condition><![CDATA[dE_dz=i*g*N*(alpha13);]]></operator>  <operator kind="cross_propagation" algorithm="RK4" propagation_dimension="z"><integration_vectors> cross2 </integration_vectors><!--You can have a dependencies tag here. --><dependencies> main </dependencies><boundary_condition kind = "right"><![CDATA[Eb = 0;]]></boundary_condition><![CDATA[dEb_dz = -i * g * N * (alphab13);]]></operator><integration_vectors> main </integration_vectors><![CDATA[real swz = (t <timeswitchz ? - 1.0 : 1.0);real omc = om * (t <timeswitchc ? 1.0 : 0.0);real omcb = om * (t <timeswitchc ? 0.0 : 1.0);dalpha12_dt = (-1.0 * gama0 - gamac + i * swz * eta * (z - samplelength/2.0) - i * (omc * omc + omcb * omcb)/delta) * (alphab12) + i * alpha13 * (omc) + i * omcb * alphab13 * (cos(2*w12*t)+i*sin(2*w12*t));dalphab12_dt = (-1.0 * gama0 - gamac - i * swz * eta * (z - samplelength/2.0) - i * (omc * omc + omcb * omcb)/delta) * (alpha12) + i * omcb * alphab13 + i * alpha13 * (omc) * (cos(2*w12*t)-i*sin(2*w12*t));dalphab13_dt=(-gama-1.0*gama0-gamac/2-i*delta)*alphab13+i*g*Eb+i* (omcb) * (alphab12);dalpha13_dt = (-gama - 1.0 * gama0 - gamac/2 - i * delta) * alpha13 + i * g * E + i * (omc) * (alpha12);]]></operators></integrate></sequence><output format="binary" filename="thlcp.xsil"> <group><sampling basis="z(800)" initial_sample="yes"><moments> alpreal12 alpimag12 alprealb12 alpimagb12 alpreal13 alpimag13 </moments><dependencies> main </dependencies><![CDATA[alpreal12 = (alpha12 + alphab12).Re();alpimag12 = (alpha12 + alphab12).Im();alpreal13 = alpha13.Re();alpimag13 = alpha13.Im();]]></sampling></group><group><sampling basis="z(800)" initial_sample="no"><moments> probereal probeimag proberealb probeimagb </moments><dependencies> cross1 cross2 </dependencies><![CDATA[probereal = E.Re();probeimag = E.Im();proberealb = Eb.Re();probeimagb = Eb.Im();]]></sampling></group></output></simulation>