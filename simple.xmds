<?xmlversion = "2.0" encoding = "UTF-8"?><simulation xmds-version="2">  <name>simple</name>  <author> AMCDawes based on work by M.Hosseini </author>  <description>    Pseudo two-level atom example simulation.  </description>  <features>    <benchmark/>    <error_check/>    <bing/>    <fftw plan="patient"/>    <globals>      <![CDATA[      const double sample_length = 1.0; //Length of the sample      const double time_input = 3; //mm      const double sigma = 1.5;      const double input_height = 1.0; // input pulse height      const double timeswitchz = 20.0;      ]]>    </globals>    <arguments>      <argument name="g" type="real" default_value="1.0" />      <argument name="gama" type="real" default_value="0.1" />      <argument name="eta" type="real" default_value="10.0" />      <argument name="N" type="real" default_value="30.0" />    </arguments>  </features><!--In the following part, all of the dimensions used in the problem are defined, but in this case, only the dimensions of "time" and "z" are needed -->  <geometry>    <propagation_dimension> t </propagation_dimension>    <transverse_dimensions>      <dimension name="z" lattice="16000" domain="(0,1)" />    </transverse_dimensions>  </geometry><vector name="main" initial_space="z" type="complex"><components> alpha </components><initialisation><![CDATA[alpha = 0;]]></initialisation></vector><vector name="cross" initial_space="z" type="complex">  <components>    E  </components></vector><!-- Here we define what differential equations need to be solved and what algorithm we want to use --><sequence><integrate algorithm="ARK89" interval="40" steps="8000" tolerance="1.0e-6"><samples> 400 400 </samples><operators><operator kind="cross_propagation" algorithm="RK4" propagation_dimension="z"><integration_vectors> cross </integration_vectors><!--You can have a dependencies tag here. --><dependencies> main </dependencies><boundary_condition kind="left"><![CDATA[E=input_height*exp(-(t-time_input)*(t-time_input)/(sigma*sigma));]]></boundary_condition><![CDATA[dE_dz=i*N*(alpha);]]></operator><integration_vectors> main </integration_vectors><![CDATA[double sw = (t < timeswitchz ? 1.0:-1.0);dalpha_dt = (-1.0*gama/2.0 - i*sw*eta*(z - sample_length/2))*alpha + i*g*E;]]></operators></integrate></sequence><output format="binary" filename="simple.xsil"> <group><sampling basis="z(800)" initial_sample="yes"><moments> alpreal alpimag </moments><dependencies> main </dependencies><![CDATA[alpreal = (alpha).Re();alpimag = (alpha).Im();]]></sampling></group><group><sampling basis="z(800)" initial_sample="no"><moments> probereal probeimag </moments><dependencies> cross </dependencies><![CDATA[probereal = E.Re();probeimag = E.Im();]]></sampling></group></output></simulation>